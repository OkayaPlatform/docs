import matter from 'gray-matter';
import isAbsoluteUrl from 'is-absolute-url';
import { isAbsolute, sep, relative } from 'path';
import { remark } from 'remark';
import remarkFrontmatter from 'remark-frontmatter';
import remarkGfm from 'remark-gfm';
import remarkMath from 'remark-math';
import remarkMdx from 'remark-mdx';
import { visit } from 'unist-util-visit';
import { slugToTitle, optionallyAddLeadingSlash } from '../generate.js';
export const createPage = async (pagePath, pageContent, contentDirectoryPath, openApiFiles, suppressErrLog = false) => {
    let metadata = {};
    try {
        const { data } = matter(pageContent);
        metadata = data;
        pageContent = await preParseMdx(pageContent, contentDirectoryPath, pagePath, suppressErrLog);
    }
    catch (err) {
        console.log(`\n ‚ö†Ô∏è  Parsing error in the frontmatter: ${getLocationErrString(pagePath, contentDirectoryPath, err)}: `);
        // TODO - pages completely break in our backend when frontmatter is broken.
        // Unify "createPage" function across applications and properly catch errors
        throw err;
    }
    // Replace .mdx so we can pass file paths into this function
    const slug = pagePath.replace(/\.mdx?$/, '');
    let defaultTitle = slugToTitle(slug);
    let description;
    // Append data from OpenAPI if it exists
    if (metadata?.openapi) {
        const { title, description: openApiDescription } = getOpenApiTitleAndDescription(openApiFiles, metadata?.openapi);
        if (title) {
            defaultTitle = title;
        }
        if (openApiDescription) {
            description = openApiDescription;
        }
    }
    const pageMetadata = {
        title: defaultTitle,
        description,
        ...metadata,
        href: optionallyAddLeadingSlash(slug),
    };
    return {
        pageMetadata,
        pageContent,
        slug: removeLeadingSlash(slug),
    };
};
export const getPageMetadataAndSlug = (pagePath, pageContent, openApiFiles) => {
    const { data: metadata } = matter(pageContent);
    // Replace .mdx, so we can pass file paths into this function
    const slug = pagePath.replace(/\.mdx?$/, '');
    let defaultTitle = slugToTitle(slug);
    // Append data from OpenAPI if it exists
    const { title, description } = getOpenApiTitleAndDescription(openApiFiles, metadata?.openapi);
    if (title) {
        defaultTitle = title;
    }
    const pageMetadata = {
        title: defaultTitle,
        description,
        ...metadata,
        href: optionallyAddLeadingSlash(slug),
    };
    return {
        pageMetadata,
        slug: removeLeadingSlash(slug),
    };
};
export const preParseMdx = async (fileContent, contentDirectoryPath, filePath, suppressErrLog = false) => {
    try {
        fileContent = await preParseMdxHelper(fileContent, contentDirectoryPath);
    }
    catch (error) {
        if (!suppressErrLog) {
            console.error(formatError(error, filePath, contentDirectoryPath));
        }
        fileContent = `üöß A parsing error occured. Please contact the owner of this website.`;
    }
    return fileContent;
};
const preParseMdxHelper = async (fileContent, contentDirectoryPath) => {
    const removeContentDirectoryPath = (filePath) => {
        const pathArr = createPathArr(filePath);
        const contentDirectoryPathArr = createPathArr(contentDirectoryPath);
        contentDirectoryPathArr.reverse().forEach((dir, index) => {
            if (pathArr[index] === dir) {
                pathArr.pop();
            }
        });
        return '/' + pathArr.join('/');
    };
    const removeContentDirectoryPaths = () => {
        return (tree) => {
            visit(tree, (node) => {
                if (node == null) {
                    return;
                }
                const n = node;
                if (n.name === 'img' || n.name === 'source') {
                    const srcAttrIndex = n.attributes.findIndex((attr) => attr?.name === 'src');
                    const nodeUrl = n.attributes[srcAttrIndex].value;
                    if (
                    // <img/> component
                    srcAttrIndex !== -1 &&
                        !isAbsoluteUrl(nodeUrl) &&
                        !isDataString(nodeUrl)) {
                        n.attributes[srcAttrIndex].value = removeContentDirectoryPath(nodeUrl);
                    }
                }
                else if (
                // ![]() format
                n.type === 'image' &&
                    n.url &&
                    !isAbsoluteUrl(n.url) &&
                    !isDataString(n.url)) {
                    n.url = removeContentDirectoryPath(n.url);
                }
            });
            return tree;
        };
    };
    const file = await remark()
        .use(remarkMdx)
        .use(remarkGfm)
        .use(remarkMath)
        .use(remarkFrontmatter, ['yaml', 'toml'])
        .use(removeContentDirectoryPaths)
        .process(fileContent);
    return String(file);
};
const removeLeadingSlash = (str) => {
    const path = createPathArr(str);
    return path.join('/');
};
const createPathArr = (path) => {
    return path.split('/').filter((dir) => dir !== '');
};
const isDataString = (str) => str.startsWith('data:');
const getOpenApiTitleAndDescription = (openApiFiles, openApiMetaField) => {
    if (openApiFiles == null || !openApiMetaField) {
        return {};
    }
    const { operation } = getOpenApiOperationMethodAndEndpoint(openApiFiles, openApiMetaField);
    if (operation == null) {
        return {};
    }
    return {
        title: operation.summary,
        description: operation.description,
    };
};
const getOpenApiOperationMethodAndEndpoint = (openApiFiles, openApiMetaField) => {
    const { endpoint, method, filename } = extractMethodAndEndpoint(openApiMetaField);
    let path;
    openApiFiles?.forEach((file) => {
        const openApiFile = file.spec;
        const openApiPath = openApiFile?.paths && openApiFile?.paths[endpoint];
        const isFilenameOrNone = !filename || filename === file.filename;
        if (openApiPath && isFilenameOrNone) {
            path = openApiPath;
        }
    });
    if (path == null) {
        return {};
    }
    let operation;
    if (method) {
        operation = path[method.toLowerCase()];
    }
    else {
        const firstOperationKey = Object.keys(path)[0];
        operation = path[firstOperationKey];
    }
    return {
        operation,
        method,
        endpoint,
    };
};
const extractMethodAndEndpoint = (openApiMetaField) => {
    const methodRegex = /(get|post|put|delete|patch)\s/i;
    const trimmed = openApiMetaField.trim();
    const foundMethod = trimmed.match(methodRegex);
    const startIndexOfMethod = foundMethod ? openApiMetaField.indexOf(foundMethod[0]) : 0;
    const endIndexOfMethod = foundMethod ? startIndexOfMethod + foundMethod[0].length - 1 : 0;
    const filename = openApiMetaField.substring(0, startIndexOfMethod).trim();
    return {
        method: foundMethod ? foundMethod[0].slice(0, -1).toUpperCase() : undefined,
        endpoint: openApiMetaField.substring(endIndexOfMethod).trim(),
        filename: filename ? filename : undefined,
    };
};
const getLocationErrString = (filePath, contentDirectoryPath, error) => {
    filePath = isAbsolute(filePath) ? relative(contentDirectoryPath, filePath) : filePath;
    let location = filePath.startsWith(`.${sep}`) || isAbsolute(filePath) ? filePath : `.${sep}${filePath}`;
    if (typeof error === 'object' && error != null && 'line' in error && error.line != null) {
        location += `:${error.line}`;
        if ('column' in error && error.column != null) {
            location += `:${error.column}`;
        }
    }
    return location;
};
const formatError = (error, filePath, contentDirectoryPath) => {
    if (typeof error !== 'object' || error == null) {
        return `\n ‚ö†Ô∏è  Parsing error: ${filePath} - ${error}`;
    }
    const location = getLocationErrString(filePath, contentDirectoryPath, error);
    const errorString = 'reason' in error && error.reason != null ? error.reason : error;
    return `\n ‚ö†Ô∏è  Parsing error: ${location} - ${errorString}`;
};
