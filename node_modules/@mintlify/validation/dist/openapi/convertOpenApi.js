import { convertParameters } from './convertParameters.js';
import { convertSchema } from './convertSchema.js';
import { convertSecurity } from './convertSecurity.js';
import { convertServers } from './convertServers.js';
import { generateExampleFromSchema } from './generateExampleFromSchema.js';
export const generateMessage = (path, messages = []) => {
    const pathString = path
        .map((component) => component.replace('\\', '\\\\').replace('/', '\\/'))
        .join('/');
    return [pathString, ...messages].join('\n');
};
export class InvalidSchemaError extends Error {
    constructor(path, ...messages) {
        super(generateMessage(path, messages));
        this.name = 'InvalidSchemaError';
        Object.setPrototypeOf(this, InvalidSchemaError.prototype);
    }
}
export class ImpossibleSchemaError extends Error {
    constructor(path, ...messages) {
        super(generateMessage(path, messages));
        this.name = 'ImpossibleSchemaError';
        Object.setPrototypeOf(this, ImpossibleSchemaError.prototype);
    }
}
export class ConversionError extends Error {
    constructor(path, ...messages) {
        super(generateMessage(path, messages));
        this.name = 'ConversionError';
        Object.setPrototypeOf(this, ConversionError.prototype);
    }
}
export const convertContent = (path, content, required) => {
    if (content === undefined) {
        return {};
    }
    const newEntries = Object.entries(content).map(([contentType, mediaObject]) => {
        const schemaArray = convertSchema([...path, contentType, 'schema'], mediaObject.schema, required);
        const examples = convertExamples(mediaObject.examples, mediaObject.example, schemaArray);
        return [contentType, { schemaArray, examples }];
    });
    return Object.fromEntries(newEntries);
};
export const convertExamples = (examples, example, schemaArray) => {
    if (examples && Object.values(examples).some(({ value }) => value !== undefined)) {
        return Object.fromEntries(Object.entries(examples)
            .filter(([_, { value }]) => value !== undefined)
            .map(([key, example]) => [
            key,
            {
                summary: example.summary,
                description: example.description,
                value: example.value,
            },
        ]));
    }
    if (example !== undefined) {
        return { example: { value: example } };
    }
    return { example: { value: generateExampleFromSchema(schemaArray[0]) } };
};
export const convertResponses = (path, responses) => {
    const newEntries = Object.entries(responses).map(([statusCode, response]) => [
        statusCode,
        convertContent([...path, statusCode, 'content'], response.content),
    ]);
    return Object.fromEntries(newEntries);
};
export const convertOpenAPIV3_1ToEndpoint = (spec, path, method) => {
    var _a, _b, _c, _d, _e;
    const paths = spec.paths;
    if (paths === undefined) {
        throw new InvalidSchemaError(['#'], 'paths not defined');
    }
    const pathObject = paths[path];
    if (pathObject === undefined) {
        throw new InvalidSchemaError(['#', 'paths'], `path not defined: ${path}`);
    }
    const operationObject = pathObject[method];
    if (operationObject === undefined) {
        throw new InvalidSchemaError(['#', 'paths', path], `operation does not exist: ${method}`);
    }
    const securityRequirements = (_a = operationObject.security) !== null && _a !== void 0 ? _a : spec.security;
    const securitySchemes = (_b = spec.components) === null || _b === void 0 ? void 0 : _b.securitySchemes;
    const security = convertSecurity({
        securityRequirements,
        securitySchemes,
    });
    const pathParameters = pathObject.parameters;
    const operationParameters = operationObject.parameters;
    const parameters = convertParameters({
        path: ['#', 'paths', path],
        method,
        pathParameters: pathParameters,
        operationParameters: operationParameters,
    });
    const servers = convertServers({
        servers: (_d = (_c = operationObject.servers) !== null && _c !== void 0 ? _c : pathObject.servers) !== null && _d !== void 0 ? _d : spec.servers,
    });
    const description = (_e = operationObject.description) !== null && _e !== void 0 ? _e : pathObject === null || pathObject === void 0 ? void 0 : pathObject.description;
    const requestBody = operationObject.requestBody;
    const body = convertContent(['#', 'paths', path, method, 'requestBody', 'content'], requestBody === null || requestBody === void 0 ? void 0 : requestBody.content, requestBody === null || requestBody === void 0 ? void 0 : requestBody.required);
    const deprecated = !!operationObject.deprecated;
    const response = convertResponses(['#', 'paths', path, method, 'responses'], operationObject.responses);
    return {
        description,
        path,
        method,
        servers,
        request: {
            security,
            parameters,
            body,
        },
        response,
        deprecated,
    };
};
